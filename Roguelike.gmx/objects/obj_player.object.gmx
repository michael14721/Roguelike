<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_saitama</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>scr_view_init();

instance_create(x, y, obj_weapon);

intensity = 16;
time = room_speed * 0.2;

k_jmp = ord("W");
k_rgt = ord("D");
k_lft = ord("A");
k_dwn = ord("S");

grav = 0.5;
max_hspd = 6;
max_vspd = 15;
acc = 1;
fric = 0.5;

dir_x = 0;
hspd = 0;
vspd = 0;
onjt = 0;
jump = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>with(obj_weapon){
    x = other.x + 2 * sign(other.image_xscale);
    y = other.y + 13;
    
    if (other.image_xscale == 1){
        image_angle = point_direction(x, y, mouse_x, mouse_y) - 45 - attack_angle;
        image_xscale = 1;
    } else {
        image_angle = point_direction(x, y, mouse_x, mouse_y) - 135 + attack_angle;
        image_xscale = -1;
    }
}


// Limit player to room width
x = median(-sprite_width * 0.5, x, room_width - sprite_width * 0.5);

// Update view
// Formula: x -= (target.x - x) * speed;
var xx, yy;
xx = view_xview - (view_xview + view_wview * 0.5 - x - image_xscale * 48) * 0.1;
yy = median(0, view_yview - (view_yview + view_hview * 0.5 - y) * 0.2, room_height - view_hview);

scr_view_update(xx, yy, -1, intensity, time);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Don't listen to your computer

// Get direction
dir_x = (keyboard_check(k_rgt) - keyboard_check(k_lft));

if (dir_x == 0) {
    hspd -= fric * sign(hspd);
} else {
    hspd = median(-max_hspd, hspd + (acc * sign(dir_x)), max_hspd);
}

if (sign(mouse_x - x) != 0) {
    image_xscale = sign(mouse_x - x);
}

// Walk slowly backwards
if (sign(mouse_x - x) != sign(dir_x)){
    max_hspd = 4;
} else {
    max_hspd = 6;
}

// Walking animation
if (abs(hspd) &gt; 1) {
    image_speed = abs(hspd) * 0.05;
} else {
    image_speed = 0;
    image_index = 1;
}

// Move horizontally
repeat ceil(abs(hspd)) {
    if (!place_meeting(x + sign(hspd), y, par_wall)) {
        x += sign(hspd);
    } else {
        hspd = 0;
    }
}

// Check for jump-through platforms
if (keyboard_check(k_dwn)) {
    onjt = false;
} else {
    for (i = 1; i &lt; 2 + abs(vspd); i ++) {
        var a;
        a = instance_place(x, y + i, par_wall_jt);
        
        if (a &gt; 0) {
            if (vspd &gt; 0 &amp;&amp; bbox_bottom &lt; a.bbox_top &amp;&amp; !position_meeting(a.x, a.y - 1, par_wall_jt)) {
                onjt = true;
                y += i - 1;
                vspd = 0;           
            }
        } else {
            onjt = false;
        }
    }
}

// Leap to jump-through platform when close enough
var a;
a = instance_position(x, y - i, par_wall_jt);

if (a &gt; 0) {
    if (abs(a.bbox_bottom - bbox_bottom) &lt; 16 &amp;&amp; vspd &lt; 0 &amp;&amp; vspd &gt; -5) {
        vspd -= 7;
    }
}

// Jump
if ((place_meeting(x, y + 1, par_wall) || onjt)) {
    jump = 0;
}

if (keyboard_check_pressed(k_jmp) &amp;&amp; jump &lt; 2) {
    jump ++;
    vspd = -13;
}

// Variable jumping height
if (keyboard_check_released(k_jmp) &amp;&amp; vspd &lt; 0) {
    vspd *= 0.6;
}

// Gravity
vspd = median(-max_vspd, max_vspd, vspd + (!place_meeting(x, y + 1, par_wall) &amp;&amp; !onjt) * grav);

// Vertical wall collision
repeat (abs(ceil(vspd))) {
    if (place_meeting(x, y + sign(vspd), par_wall)) {
        vspd = 0;
    } else {
        y += sign(vspd);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();

if(instance_exists(obj_inventory)){
    var inventory_slot = obj_inventory.inv_items[obj_inventory.slot_helm];
    if(inventory_slot != -1){
        draw_sprite_ext(spr_head_helm, inventory_slot, x, y - 12 + 2 * (image_index % 2), image_xscale, 1, 0, c_white, 1);
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
